<!DOCTYPE html>
<!--http://www.kirupa.com/html5/create_an_analog_clock_using_the_canvas.htm-->
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Smartclock MISA</title>
    <style>
        .body {
            background-color: black;
        }
        #clock {
            border: 1px solid #000000;
        }
    </style>
</head>
<body class="body">
<!-- TODO redesign pour format rectangle height="1280px" -->
<canvas id="clock" height="800px" width="800px" >
    If you can see this message, your browser does not support canvas
    and needs an upate. Sorry. :(
</canvas>
<script>
    (function () {

        //TODO mettre l'init dans un constructeur
        var canvas = document.getElementById("clock");
        var context = canvas.getContext("2d");

        // Rayon de l'horloge
        var clockRadius = canvas.width / 2;

        // Center clock in the canvas
        var centerX = canvas.width / 2;
        var centerY = canvas.height / 2;

        // Must define TAU
        Math.TAU = 2 * Math.PI;

        document.addEventListener('DOMContentLoaded', startTimer);
        //TODO end init

        function startTimer() {
            setInterval(updateClock, 1000);
        }

        function updateClock() {
            resetCanvas();
            drawOriginCircle();
            drawHourMarkers();
            drawAnalogTime();
        }

        function drawAnalogTime() {
            var now = new Date();

            //TODO passer une config {} au drawArm
            var hour = now.getHours() % 12;
            var min = now.getMinutes();
            var sec = now.getSeconds();

            var secProgress = (sec / 60);
            var minProgress = (min / 60) + (1 / 60) * secProgress;
            var hourProgress = (hour / 12) + (1 / 12) * minProgress;

            const hourThickness = 6;
            const minThickness = 4;
            const secThickness = 2;

            const hourArmPercentLength = 0.45;
            const minArmPercentLength = 0.60;
            const secArmPercentLength = 0.72;

            drawArm(hourProgress, hourThickness, hourArmPercentLength, '#FFFFFF');
            drawArm(minProgress, minThickness, minArmPercentLength, '#FFFFFF');
            drawArm(secProgress, secThickness, secArmPercentLength, '#FF0000');
        }

        function resetCanvas() {
            context.clearRect(0, 0, canvas.width, canvas.height);
        }

        function drawOriginCircle() {
            context.beginPath();
            context.arc(centerX, centerY, 7, 0, 2 * Math.PI);
            context.fillStyle = "white";
            context.fill();
        }

        /**
         * Dessine les repères pour les heures dans le fond
         */
        function drawHourMarkers() {
            context.strokeStyle = '#FFFFFF';
            for (var hour = 0; hour < 12; hour++) {
                var isQuarter = !(hour % 3);
                if (isQuarter) {
                    context.lineWidth = 6;
                    drawLine(hour / 12, 0.7, 1);
                } else {
                    context.lineWidth = 4;
                    drawLine(hour / 12, 0.8, 1.2);
                }
            }
        }

        /**
         * Dessine une aiguille
         * @param progress
         * @param armThickness
         * @param armLength
         * @param armColor
         */
        function drawArm(progress, armThickness, armLength, armColor) {
            const shiftFromCenter = 15;
            context.lineWidth = armThickness;
            context.strokeStyle = armColor;

            drawLine(progress, shiftFromCenter / clockRadius, armLength);
        }

        /**
         * @param progress pourcentage de progression ex: 3h = 15min = 0.25; 6h = 30 min = 0.5
         * @param beginPercent début de la ligne en % du rayon
         * @param endPercent fin de la ligne en % du rayon
         */
        function drawLine(progress, beginPercent, endPercent) {
            var armRadians = (Math.TAU * (progress)) - (Math.TAU / 4);
            var startingPointX = centerX + Math.cos(armRadians) * (beginPercent * clockRadius);
            var startingPointY = centerY + Math.sin(armRadians) * (beginPercent * clockRadius);
            var endingPointX = centerX + Math.cos(armRadians) * (endPercent * clockRadius);
            var endingPointY = centerY + Math.sin(armRadians) * (endPercent * clockRadius);

            context.beginPath();
            context.moveTo(startingPointX, startingPointY);
            context.lineTo(endingPointX, endingPointY);
            context.stroke();
        }

    })();
</script>

</body>
</html>